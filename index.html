<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Kis Herceg â€“ RendelÃ©s keresÅ‘</title>
<style>
  body{font-family:Arial;max-width:640px;margin:auto;padding:18px}
  input{width:100%;padding:12px;font-size:16px;box-sizing:border-box}
  button{margin-top:10px;padding:12px;width:100%;font-size:16px;cursor:pointer}
  .box{margin-top:14px;padding:12px;border:1px solid #ddd;border-radius:10px}
</style>
</head>
<body>
<h2>ğŸ“š Kis Herceg â€“ NÃ©v szerinti keresÅ‘</h2>
<p>Ãrd be a neved, Ã©s kilistÃ¡zzuk a tÃ©teleidet.</p>

<input id="name" placeholder="Pl. BÃ­rÃ³ RÃ©ka">
<button onclick="search()">KeresÃ©s</button>

<div class="box" id="result">ğŸ” KeresÃ©shez Ã­rd be a neved.</div>

<script>
async function search() {
  const qRaw = document.getElementById("name").value.trim();
  const q = qRaw.toLowerCase();
  const result = document.getElementById("result");

  if (!q) { result.innerHTML = "Ãrj be egy nevet ğŸ™‚"; return; }

  let text = "";
  try {
    const res = await fetch("rendeles.txt", { cache: "no-store" });
    text = await res.text();
  } catch (e) {
    result.innerHTML = "Nem tudtam betÃ¶lteni a rendeles.txt fÃ¡jlt ğŸ˜•";
    return;
  }

  const lines = text
    .split(/\r?\n/)
    .map(l => (l || "").trim())
    .filter(l => l.length > 0);

  const foundA = new Set();       // AjÃ¡nlÃ³s listÃ¡k cÃ­mei (ahol szerepel a nÃ©v)
  const foundB = {};              // { nÃ©v: [tÃ©telek...] }

  const clean = (s) => (s || "")
    .replace(/^["']+|["']+$/g, "")
    .replace(/\s+/g, " ")
    .trim();

  // -------- (A) AJÃNLÃ“S LISTA: "CÃM â€“ xx lej" + szÃ¡mozott nevek --------
  const isTitleLineA = (s) => {
    const t = clean(s);
    // legyen benne "lej" Ã©s valamilyen kÃ¶tÅ‘jel/gondolatjel, Ã©s ne legyen "NÃ‰V:"
    return /lej/i.test(t) && /[-â€“â€”]/.test(t) && !/^NÃ‰V\s*:/i.test(t) && !/bookline rendelÃ©s/i.test(t);
  };

  for (let i = 0; i < lines.length; i++) {
    const line = clean(lines[i]);
    if (!isTitleLineA(line)) continue;

    const title = line;
    // a kÃ¶vetkezÅ‘ soroktÃ³l olvasunk neveket amÃ­g jÃ¶n Ãºj cÃ­m (A), vagy nÃ©v-blokk (B)
    for (let j = i + 1; j < lines.length; j++) {
      const l2raw = clean(lines[j]);
      if (isTitleLineA(l2raw)) break;
      if (/^NÃ‰V\s*:/i.test(l2raw)) break;
      if (/bookline rendelÃ©s/i.test(l2raw)) break;

      // "1. NÃ©v" / "2. NÃ©v" / "3. NÃ©v"
      const nameLine = l2raw.replace(/^\d+\.\s*/, "").trim();
      if (!nameLine) continue;

      if (nameLine.toLowerCase().includes(q)) {
        foundA.add(title);
      }
    }
  }

  // -------- (B) BOOKLINE: "NÃ‰V: ..." + â€¢ tÃ©telek / vagy "NÃ©v â€“ Bookline rendelÃ©s..." --------
  const getNameFromHeader = (s) => {
    const t = clean(s);

    // 1) NÃ‰V: Valaki
    let m = t.match(/^NÃ‰V\s*:\s*(.+)$/i);
    if (m) return clean(m[1]);

    // 2) "Valaki â€“ Bookline rendelÃ©s DECEMBER 1."
    if (/bookline rendelÃ©s/i.test(t) && /[-â€“â€”]/.test(t)) {
      const namePart = t.split(/[-â€“â€”]/)[0];
      return clean(namePart);
    }

    return null;
  };

  for (let i = 0; i < lines.length; i++) {
    const header = clean(lines[i]);
    const name = getNameFromHeader(header);
    if (!name) continue;

    // ha a nÃ©v nem talÃ¡lhatÃ³, akkor is Ã¡t kell lÃ©pni a tÃ©teleken a kÃ¶vetkezÅ‘ headerig
    const nameMatches = name.toLowerCase().includes(q);
    let items = [];

    for (let j = i + 1; j < lines.length; j++) {
      const l2 = clean(lines[j]);

      // megÃ¡llunk, ha Ãºj nÃ©v header jÃ¶n
      if (getNameFromHeader(l2)) { i = j - 1; break; }

      // tÃ©tel sorok: â€¢ valami / - valami
      if (/^[â€¢\-Â·]\s*/.test(l2)) {
        const item = clean(l2.replace(/^[â€¢\-Â·]\s*/, ""));
        if (item) items.push(item);
      } else {
        // ha nincs bullet, de mÃ©gis tÃ©tel-szerÅ± sor (pl. "Valami â€“ 55 lej")
        if (/lej/i.test(l2)) items.push(l2);
      }

      // ha a fÃ¡jl vÃ©gÃ©n vagyunk
      if (j === lines.length - 1) i = j;
    }

    if (nameMatches && items.length) {
      if (!foundB[name]) foundB[name] = [];
      // duplikÃ¡ciÃ³k ellen
      items.forEach(it => { if (!foundB[name].includes(it)) foundB[name].push(it); });
    }
  }

  // -------- KIMENET --------
  if (foundA.size === 0 && Object.keys(foundB).length === 0) {
    result.innerHTML = "âŒ Nem talÃ¡ltunk talÃ¡latot ezzel a nÃ©vvel.";
    return;
  }

  let html = âœ… TalÃ¡lat: <b>${qRaw}</b><br><br>;

  if (foundA.size) {
    html += <b>ğŸ“Œ AjÃ¡nlÃ³s listÃ¡k:</b><br>;
    [...foundA].forEach(t => { html += â€¢ ${t}<br>; });
    html += <br>;
  }

  const names = Object.keys(foundB);
  if (names.length) {
    html += <b>ğŸ§¾ Bookline / tÃ¡blÃ¡zatos rendelÃ©sek:</b><br><br>;
    names.forEach(n => {
      html += <b>${n}</b><br>;
      foundB[n].forEach(it => { html += â€¢ ${it}<br>; });
      html += <br>;
    });
  }

  result.innerHTML = html;
}

// Enterre is keressen
document.addEventListener("DOMContentLoaded", () => {
  const inp = document.getElementById("name");
  if (inp) inp.addEventListener("keydown", (e) => {
    if (e.key === "Enter") search();
  });
});
</script>
</body>
</html>
